\subsection{TweetNaCl specifics}
\label{subsec:Number-TweetNaCl}

As its name suggests, TweetNaCl aims for code compactness (\emph{``a crypto library in 100 tweets''}).
As a result it uses a few defines and typedefs to gain precious bytes while
still remaining human-readable.
\begin{lstlisting}[language=Ctweetnacl,stepnumber=0]
#define FOR(i,n) for (i = 0;i < n;++i)
#define sv static void
typedef unsigned char u8;
typedef long long i64;
\end{lstlisting}

TweetNaCl functions take pointers as arguments. By convention the first one
points to the output array \texttt{o}. It is then followed by the input arguments.

Due to some limitations of VST, indexes used in \TNaCle{for} loops have to be
of type \TNaCle{int} instead of \TNaCle{i64}. We changed the code to allow our
proofs to carry through. We believe this does not affect the correctness of the
original code. A complete diff of our modifications to TweetNaCl can be found in
Appendix~\ref{verified-C-and-diff}.


\subsection{X25519 in TweetNaCl}
\label{subsec:X25519-TweetNaCl}

We now describe the implementation of X25519 in TweetNaCl.

\subheading{Arithmetic in \Ffield.}
In X25519, all computations are performed in $\F{p}$.
Throughout the computation, elements of that field
are represented in radix $2^{16}$,
i.e., an element $A$ is represented as $(a_0,\dots,a_{15})$,
with $A = \sum_{i=0}^{15}a_i2^{16i}$.
The individual ``limbs'' $a_i$ are represented as
64-bit \TNaCle{long long} variables:
\begin{lstlisting}[language=Ctweetnacl,stepnumber=0]
typedef i64 gf[16];
\end{lstlisting}

The conversion from the input byte array to this representation in radix
$2^{16}$ is done with the \TNaCle{unpack25519} function.

The radix-$2^{16}$ representation in limbs of $64$ bits is
highly redundant; for any element $A \in \Ffield$ there are
multiple ways to represent $A$ as $(a_0,\dots,a_{15})$.
This is used to avoid or delay carry handling in basic operations such as
Addition (\TNaCle{A}), subtraction (\TNaCle{Z}), multiplication (\TNaCle{M})
and squaring (\TNaCle{S}). After a multiplication, limbs of the result
\texttt{o} are too large to be used again as input. Two calls to
\TNaCle{car25519} at the end of \TNaCle{M} takes care of the carry propagation.

Inverses in $\Ffield$ are computed with \TNaCle{inv25519}.
This function uses exponentiation by $p - 2 = 2^{255}-21$,
computed with the square-and-multiply algorithm.

\TNaCle{sel25519} implements a constant-time conditional swap (\texttt{CSWAP}) by
applying a mask between two fields elements.

% Finally, we need the \TNaCle{pack25519} function,
% which converts from the internal redundant radix-$2^{16}$
Finally, the \TNaCle{pack25519} function
converts the internal redundant radix-$2^{16}$
representation to a unique byte array representing an
integer in $\{0,\dots,p-1\}$ in little-endian format.
This function is considerably more complex as it needs to convert
to a \emph{unique} representation, i.e., also fully reduce modulo
$p$ and remove the redundancy of the radix-$2^{16}$ representation.

The C definitions of those functions are available in
Appendix \ref{verified-C-and-diff}.

\subheading{The Montgomery ladder.}
With these low-level arithmetic and helper functions defined,
we can now turn our attention to the core of the X25519 computation:
the \TNaCle{crypto_scalarmult} API function of TweetNaCl,
which is implemented through the Montgomery ladder.

\begin{lstlisting}[language=Ctweetnacl]
int crypto_scalarmult(u8 *q,
                      const u8 *n,
                      const u8 *p)
{
  u8 z[32];
  i64 r;
  int i;
  gf x,a,b,c,d,e,f;
  FOR(i,31) z[i]=n[i];
  z[31]=(n[31]&127)|64;
  z[0]&=248;
  unpack25519(x,p);
  FOR(i,16) {
    b[i]=x[i];
    d[i]=a[i]=c[i]=0;
  }
  a[0]=d[0]=1;
  for(i=254;i>=0;--i) {
    r=(z[i>>3]>>(i&7))&1;
    sel25519(a,b,r);
    sel25519(c,d,r);
    A(e,a,c);
    Z(a,a,c);
    A(c,b,d);
    Z(b,b,d);
    S(d,e);
    S(f,a);
    M(a,c,a);
    M(c,b,e);
    A(e,a,c);
    Z(a,a,c);
    S(b,a);
    Z(c,d,f);
    M(a,c,_121665);
    A(a,a,d);
    M(c,c,a);
    M(a,d,f);
    M(d,b,x);
    S(b,e);
    sel25519(a,b,r);
    sel25519(c,d,r);
  }
  inv25519(c,c);
  M(a,a,c);
  pack25519(q,a);
  return 0;
}
\end{lstlisting}

Note that lines 10 \& 11 represent the ``clamping'' operation.
