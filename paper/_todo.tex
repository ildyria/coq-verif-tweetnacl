% DEADLINE: Tuesday 21 at Noon.

\todo{

- Get down to 12 pages: "no more than 12 pages long, excluding the bibliography,
well-marked appendices, and supplementary material."

- Change the story: Verification of a crypto software from C up to Maths and
usable in protocol verification.

- Emphasize:\\
+ the added confidence between in X25519 Correctness\\
+ proof of real world software\\
}

With respect to the reviews:

\todo{

- Give number of person-hours\\
+ ARGUE WHY WE DID NOT

- "This did not become very clear, because you mostly describe names
of tool while leaving out the details of what these tools carry out
conceptually."\\
+ anotation have to be carried out through the proof to help the smt-solver,
not in our case as we direct the proof.\\
=> DO we write that in the intro or in the answer?

- "I was wondering whether you consider the approach in [13] as synthesis or
verification, because to me, it seemed a mix/neither."\\
+ [13] is "Verified Low-Level Programming Embedded in F*",\\
+ reread [13] and answer in the "our answer part"\\
+ => While the title says Verified Low-Level Programming, they generate C code,
so by definition it is synthesis. However, Low* forces the user to anotate the
code (if necessary) and uses a SMT solver to prove the memory safety,
correctness etc. at the Low* level. Depending of the level being considered.

- "[18] even uses Coq to verify a large portion of a C implementation of X25519
fully automatically."\\
+ This is not verification, this is synthesis. The approach is completely different.

- "Still, TweetNaCl is not necessarily the most complex (and certainly not the most
efficient) implementation of X25519 that has been verified, which makes the
novelty of this work hard to justify."\\
+ True, but all the other works have been from a spec and generate correct code
approach, here we go the opposite way. While the code of other libraries are
different, the montgomery ladder are often similar and the optimizations comes
mostly from the big number computations.\\

- "It also appears that the authors do not verify the constant-time
guarantees of the TweetNaCl code. Could this be done in their
framework?"
+ Nope => mention in limitation at the end of the paper?

- Clamping and section V.\\
+ The clamping allows to reduce the group to prime elements, we do not provide
such proofs.\\
- We prove that for all n the computations on the ladder holds.

- "More importantly, could you claim that your proof of equivalence also provides
a justification for the implementations of Fiat Crypto or HACL*, hence adding
value to those other projects in addition to your own?"
+ Peter ?
}

\newpage
\pagenumbering{arabic}% Arabic page numbers (and reset to 1)
