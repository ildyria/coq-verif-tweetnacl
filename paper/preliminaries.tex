\section{Preliminaries}
\label{preliminaries}

In this section, we first give a brief summary of the mathematical background
on elliptic curves. We then describe X25519 and its implementation in TweetNaCl.
Finally, we provide a brief description of the formal tools we use in our proofs.

\subsection{Arithmetic on Montgomery curves}
\label{subsec:montgomery}

\begin{definition}
Let $a,b \in \K$, $M_{a,b}$ is a Montgomery curve defined over a field $\K$ with equation:
$$M_{a,b}: by^2 = x^3 + ax^2 + x$$
where $a^2 \neq 4$ and $b \neq 0$.
\end{definition}

\begin{definition}
For any algebraic extension $\L$ of $\K$, $\K \subseteq	\L$,
$M_{a,b}(\L)$ is the set of $\L$-rational points which satisfy the equation with
addition to the point at infinity $\Oinf$.
$$M_{a,b}(\L) = \{\Oinf\} \cup \{(x,y) \in \L \times \L~|~by^2 = x^3 + ax^2 + x\}$$
\end{definition}

For $M_{a,b}$ over $\F{p}$, the parameter $b$ is known as the ``twisting factor'',
for $b'\in \F{p}\backslash\{0\}$ and $b' \neq b$, the curves $M_{a,b}$ and $M_{a,b'}$
are isomorphic via $(x,y) \mapsto (x, \sqrt{b'/b} \cdot y)$.
When $b'/b$ is not a square in \F{p}, $M_{a,b'}$ is a quadratic twist of $M_{a,b}$:
isomorphic over $\F{p^2}$~\cite{cryptoeprint:2017:212}.

Points over $M_{a,b}(\K)$ can be equipped with a structure of an abelian group
with the addition operation $\oplus$ and with neutral element the point at infinity $\Oinf$.
Using this law, we have the scalar multiplication over $M_{a,b}(\K)$ defined by:
  $$n\cdot P = \underbrace{P \oplus \cdots \oplus P}_{n\text{ times}}$$

\begin{align*}
\texttt{xADD} &: (X_P, Z_P, X_Q , Z_Q, X_{P-Q}, Z_{P-Q}) \mapsto (X_{P+Q}, Z_{P+Q})\\
\texttt{xDBL} &: (X_P, Z_P) \mapsto (X_{2P}, Z_{2P})\\
\end{align*}

\begin{algorithm}
\caption{Montgomery ladder for scalar mult.}
\label{montgomery-ladder}
\begin{algorithmic}
\REQUIRE{x-coordinate of $P$ : $P.x$, scalars $n$ and $m$, $n < 2^m$}
\ENSURE{$Q = n \cdot P$}
\STATE $Q \leftarrow (X_P, Z_P)$
\STATE $R \leftarrow \Oinf$
\FOR{$k$ := $m$ down to $1$}
  \IF{$k^{\text{th}}$ bit of $n$ is $0$}
    \STATE $R \leftarrow \texttt{xADD}(Q,R,X_P,Z_P)$
    \STATE $Q \leftarrow \texttt{xDBL}(X_P, Z_P)$
  \ELSE
  \STATE $Q \leftarrow \texttt{xADD}(Q,R,X_P,Z_P)$
  \STATE $R \leftarrow \texttt{xDBL}(X_P, Z_P)$
  \ENDIF
\ENDFOR
\end{algorithmic}
\end{algorithm}

\subsection{The X25519 key exchange}
\label{preliminaries:A}

\todo{Rephrase, use byte arrays, define clamping, state where things live.}

For any value $x \in \F{p}$, for the elliptic curve $E$ over $\F{p^2}$
defined by $y^2 = x^3 + 486662 x^2 + x$, there exist a point $P$ over $E(\F{p^2})$
such that $x$ is the $x$-coordinate of $P$.
 % (abreviated as $P.x$).
Remark that $x$ is also the $x$-coordinate of $-P$.

Given a natural number $n$ and $x$, X25519 returns the $x$-coordinate of the
scalar multiplication of $P$ by $n$, thus $n \cdot P$. Note that the result is the
same with $n \cdot (-P) = -(n \cdot P)$.

RFC~7748~\cite{rfc7748} formalized the X25519 Diffieâ€“Hellman key-exchange algorithm.
Given the base point $B$ where $B.x=9$, each party generate a secret random number
$s_a$ (respectively $s_b$), and computes $P_a$ (respectively $P_b$), the result
of the scalar multiplication between $B$ and $s_a$ (respectively $s_b$).
The party exchanges $P_a$ and $P_b$ and computes their shared secret with X25519
over $s_a$ and $P_b$ (respectively $s_b$ and $P_a$).

\subsection{TweetNaCl specifics}
\label{preliminaries:B}
\todo{Some more text}
In order to gain space, TweetNaCl uses a few shortcuts.
\begin{lstlisting}[language=Ctweetnacl]
#define FOR(i,n) for (i = 0;i < n;++i)
#define sv static void
typedef unsigned char u8;
typedef long long i64;
\end{lstlisting}

\todo{Comment on argument order}

\subsection{X25519 in TweetNaCl}
\label{preliminaries:B}

\todo{Add a sentence or two here to prepare the reader.}

\subheading{Arithmetic in \Ffield.}
In X25519, all computations are performed in $\F{p}$.
Throughout the computation, elements of that field
are represented in radix $2^{16}$,
i.e., an element $A$ is represented as $(a_0,\dots,a_{15}$,
with $A = \sum_{i=0}^{15}a_i2^{16i}$.
The individual ``limbs'' $a_i$ are represented as
64-bit \TNaCle{long long} variables:

\begin{lstlisting}[language=Ctweetnacl]
typedef i64 gf[16];
\end{lstlisting}

Conversion from the input byte array to this representation is done
as follows:
\begin{lstlisting}[language=Ctweetnacl]
sv unpack25519(gf o, const u8 *n)
{
  int i;
  FOR(i,16) o[i]=n[2*i]+((i64)n[2*i+1]<<8);
  o[15]&=0x7fff;
}
\end{lstlisting}

The radix-$2^{16}$ representation in limbs of $64$ bits is
highly redundant; for any element $A \in \F{\p}$ there are
multiple ways to represent $A$ as $(a_0,\dots,a_{15})$.
For example, it is used to avoid carry handling in
the implementations of addition (\TNaCle{A})
and subtraction (\TNaCle{Z}) in $\F{\p}$:

\begin{lstlisting}[language=Ctweetnacl]
sv A(gf o,const gf a,const gf b) {
  int i;
  FOR(i,16) o[i]=a[i]+b[i];
}

sv Z(gf o,const gf a,const gf b) {
  int i;
  FOR(i,16) o[i]=a[i]-b[i];
}
\end{lstlisting}

Also multiplication (\TNaCle{M}) is heavily exploiting the redundancy
of the representation to delay carry handling.

\begin{lstlisting}[language=Ctweetnacl]
sv M(gf o,const gf a,const gf b) {
  i64 i,j,t[31];
  FOR(i,31) t[i]=0;
  FOR(i,16) FOR(j,16) t[i+j]+=a[i]*b[j];
  FOR(i,15) t[i]+=38*t[i+16];
  FOR(i,16) o[i]=t[i];
  car25519(o);
  car25519(o);
}
\end{lstlisting}

After the actual multiplication, the limbs of the result \texttt{o} are
too large to be used again as input, which is why the two calls to
\TNaCle{car25519} at the end of \TNaCle{M} propagate the carries through the limbs:

\begin{lstlisting}[language=Ctweetnacl]
sv car25519(gf o)
{
  int i;
  FOR(i,16) {
    o[(i+1)%16]+=(i<15?1:38)*(o[i]>>16);
    o[i]&=0xffff;
  }
}
\end{lstlisting}
% In order to simplify the verification of this function,
% we extract the last step of the loop $i = 15$.
% \begin{lstlisting}[language=Ctweetnacl]
% sv car25519(gf o)
% {
%   int i;
%   i64 c;
%   FOR(i,15) {
%     o[(i+1)]+=o[i]>>16;
%     o[i]&=0xffff;
%   }
%   o[0]+=38*(o[15]>>16);
%   o[15]&=0xffff;
% }
% \end{lstlisting}

Inverse in $\Zfield$ are computed with \TNaCle{inv25519}.
It takes the exponentiation by $2^{255}-21$ with the Square-and-multiply algorithm.
Fermat's little theorem brings the correctness.
Notice that in this case the inverse of $0$ is defined as $0$.

\TNaCle{sel25519} implements a constant-time conditional swap by applying a mask between
two fields elements.
% \begin{lstlisting}[language=Ctweetnacl]
% sv sel25519(gf p,gf q,i64 b)
% {
%   int i;
%   i64 t,c=~(b-1);
%   FOR(i,16) {
%     t= c&(p[i]^q[i]);
%     p[i]^=t;
%     q[i]^=t;
%   }
% }
% \end{lstlisting}

% It takes advantage of the shape of the number by not doing the multiplications only twice.

% \todo{Ladder algorithm C code}
% \todo{Ladderstep algorithm C code}

Finally, we require the \TNaCle{pack25519} function,
which converts from the internal redundant radix-$2^{16}$
representation to a unique byte array:

\begin{lstlisting}[language=Ctweetnacl]
sv pack25519(u8 *o,const gf n)
{
  int i,j;
  i64 b;
  gf t,m={0};
  set25519(t,n);
  car25519(t);
  car25519(t);
  car25519(t);
  FOR(j,2) {
    m[0]=t[0]- 0xffed;
    for(i=1;i<15;i++) {
      m[i]=t[i]-0xffff-((m[i-1]>>16)&1);
      m[i-1]&=0xffff;
    }
    m[15]=t[15]-0x7fff-((m[14]>>16)&1);
    m[14]&=0xffff;
    b=1-((m[15]>>16)&1);
    sel25519(t,m,b);
  }
  FOR(i,16) {
    o[2*i]=t[i]&0xff;
    o[2*i+1]=t[i]>>8;
  }
}
\end{lstlisting}

As we can see, this function is considerably more complex than the
unpacking function. The reason is that it needs to convert
to a \emph{unique} representation before packing into the output
byte array.

\subheading{The Montgomery ladder.}
With these low-level arithmetic and helper function at hand, we can now
turn our attention to the core of the X25519 computation:
the \TNaCle{crypto\_scalarmult} API function of TweetNaCl.
In order to compute the scalar multiplication,
X25519 uses the Montgomery ladder~\cite{Mon85}.
\todo{explain, projective coordinates, etc}
of .
First extract and clamp the value of $n$. Then unpack the value of $p$.
As per RFC~7748~\cite{rfc7748}, set its most significant bit to 0.
Finally compute the Montgomery ladder over the clamped $n$ and $p$,
and pack the result into $q$.
\begin{lstlisting}[language=Ctweetnacl]
int crypto_scalarmult(u8 *q,
                      const u8 *n,
                      const u8 *p)
{
  u8 z[32];
  i64 r;
  int i;
  gf x,a,b,c,d,e,f;
  FOR(i,31) z[i]=n[i];
  z[31]=(n[31]&127)|64;
  z[0]&=248;
  unpack25519(x,p);
  FOR(i,16) {
    b[i]=x[i];
    d[i]=a[i]=c[i]=0;
  }
  a[0]=d[0]=1;
  for(i=254;i>=0;--i) {
    r=(z[i>>3]>>(i&7))&1;
    sel25519(a,b,r);
    sel25519(c,d,r);
    A(e,a,c);
    Z(a,a,c);
    A(c,b,d);
    Z(b,b,d);
    S(d,e);
    S(f,a);
    M(a,c,a);
    M(c,b,e);
    A(e,a,c);
    Z(a,a,c);
    S(b,a);
    Z(c,d,f);
    M(a,c,_121665);
    A(a,a,d);
    M(c,c,a);
    M(a,d,f);
    M(d,b,x);
    S(b,e);
    sel25519(a,b,r);
    sel25519(c,d,r);
  }
  inv25519(c,c);
  M(a,a,c);
  pack25519(q,a);
  return 0;
}
\end{lstlisting}

\subsection{Coq and VST}
\label{preliminaries:C}

Coq~\cite{coq-faq} is an interactive theorem prover. It provides an expressive
formal language to write mathematical definitions, algorithms and theorems coupled
with their proofs. As opposed to other systems such as F*~\cite{DBLP:journals/corr/BhargavanDFHPRR17},
Coq does not rely on an SMT solver in its trusted code base.
It uses its type system to verify the applications of hypotheses,
lemmas, and theorems~\cite{Howard1995-HOWTFN}.

Hoare logic is a formal system which allows reasoning about programs.
It uses triples such as
$$\{{\color{doc@lstnumbers}\textbf{Pre}}\}\texttt{~Prog~}\{{\color{doc@lstdirective}\textbf{Post}}\}$$
where ${\color{doc@lstnumbers}\textbf{Pre}}$ and ${\color{doc@lstdirective}\textbf{Post}}$
are assertions and \texttt{Prog} is a piece of code.
It is read as
``when the precondition  ${\color{doc@lstnumbers}\textbf{Pre}}$ is met,
executing \texttt{Prog} will yield postcondition ${\color{doc@lstdirective}\textbf{Post}}$''.
We use compositional rules to prove the truth value of a Hoare triple.
For example, here is the rule for sequential composition:
\begin{prooftree}
  \AxiomC{$\{P\}C_1\{Q\}$}
  \AxiomC{$\{Q\}C_2\{R\}$}
  \LeftLabel{Hoare-Seq}
  \BinaryInfC{$\{P\}C_1;C_2\{R\}$}
\end{prooftree}
Separation logic is an extension of Hoare logic which allows reasoning about
pointers and memory manipulation. This logic enforces strict conditions on the
memory shared such as being disjoint. We discuss this limitation further in Section~\ref{using-VST}.
The Verified Software Toolchain (VST)~\cite{cao2018vst-floyd} is a framework which uses
Separation logic to prove the functional correctness of C programs.
It can be seen as a forward symbolic execution of the program.
\todo{Mention CLight somewhere here.}
Its uses a strongest postcondition approach to prove that a program matches its specification.
