\section{Preliminaries}
\label{preliminaries}
\subsection{The X25519 key exchange}

\F{p}, \F{p^2}, Coordinates, X-coordinates in \F{p}.

XXX: math definition from Curve25519 paper.

\subsection{X25519 in TweetNaCl}

\subheading{Arithmetic in \Ffield}
Given a natural number $n$ and a value $x \in \F{p}$, X25519 is a function over a $\F{p}$-restricted
$x$-coordinate computing a scalar multiplication on $E(\F{p^2})$.
As a result of this restriction, all computations are done over $\F{p}$.
Numbers in that field can be represented with 256 bits.
We represent them in 8-bit limbs (respectively 16-bit limbs),
making use of a base $2^8$ (respectively $2^{16}$).
Consequently, inputs of the X25519 function are seen as arrays of bytes.
Computations inside this function makes use of the 16-bit limbs representation.
Those are placed into 64-bits signed container in order to mitigate overflows or underflows.
\begin{lstlisting}[language=Ctweetnacl]
typedef long long i64;
typedef i64 gf[16];
\end{lstlisting}
Notice this does not guaranty a unique representation of each number. i.e.\\
$\exists x,y \in$ \TNaCle{gf} such that
\vspace{-0.25cm}
  $$x \neq y\ \ \land\ \ x \equiv y \pmod{2^{255}-19}$$

On the other hand it allows simple definitions of addition (\texttt{A}),
substraction (\texttt{Z}), and school-book multiplication (\texttt{M}).
   % and squaring (\texttt{S}).
  \begin{lstlisting}[language=Ctweetnacl]
  sv A(gf o,const gf a,const gf b) {
    int i;
    FOR(i,16) o[i]=a[i]+b[i];
  }

  sv Z(gf o,const gf a,const gf b) {
    int i;
    FOR(i,16) o[i]=a[i]-b[i];
  }

  sv M(gf o,const gf a,const gf b) {
    i64 i,j,t[31];
    FOR(i,31) t[i]=0;
    FOR(i,16) FOR(j,16) t[i+j]+=a[i]*b[j];
    FOR(i,15) t[i]+=38*t[i+16];
    FOR(i,16) o[i]=t[i];
    car25519(o);
    car25519(o);
  }
  \end{lstlisting}

  To avoid overflows, carries are propagated by the \texttt{car25519} function.
  \begin{lstlisting}[language=Ctweetnacl]
  sv car25519(gf o)
  {
    int i;
    FOR(i,16) {
      o[(i+1)%16]+=(i<15?1:38)*(o[i]>>16);
      o[i]&=0xffff;
    }
  }
  \end{lstlisting}
  % In order to simplify the verification of this function,
  % we extract the last step of the loop $i = 15$.
  % \begin{lstlisting}[language=Ctweetnacl]
  % sv car25519(gf o)
  % {
  %   int i;
  %   i64 c;
  %   FOR(i,15) {
  %     o[(i+1)]+=o[i]>>16;
  %     o[i]&=0xffff;
  %   }
  %   o[0]+=38*(o[15]>>16);
  %   o[15]&=0xffff;
  % }
  % \end{lstlisting}

  Inverse in \Zfield are computed with \texttt{inv25519}.
  It takes the exponentiation by $2^{255}-21$ with the Square-and-multiply algorithm.
  Fermat's little theorem brings the correctness.
  Notice that in this case the inverse of $0$ is defined as $0$.

  % It takes advantage of the shape of the number by not doing the multiplications only twice.

  % \todo{Ladder algorithm C code}
  % \todo{Ladderstep algorithm C code}
  The last step of \texttt{crypto\_scalarmult} is the packing of the limbs: an array of 32 bytes.
  It first performs 3 carry propagations in order to guarantee
  that each 16-bit limbs values are between $0$ and $2^{16}$.
  Then computes a modulo reduction by $\p$ using iterative substraction and
  conditional swapping. This guarantees a unique representation in $\Zfield$.
  After which each 16-bit limbs are splitted into 8-bit limbs.
  \begin{lstlisting}[language=Ctweetnacl]

  sv pack25519(u8 *o,const gf n)
  {
    int i,j;
    i64 b;
    gf t,m={0};
    set25519(t,n);
    car25519(t);
    car25519(t);
    car25519(t);
    FOR(j,2) {
      m[0]=t[0]- 0xffed;
      for(i=1;i<15;i++) {
        m[i]=t[i]-0xffff-((m[i-1]>>16)&1);
        m[i-1]&=0xffff;
      }
      m[15]=t[15]-0x7fff-((m[14]>>16)&1);
      m[14]&=0xffff;
      b=1-((m[15]>>16)&1);
      sel25519(t,m,b);
    }
    FOR(i,16) {
      o[2*i]=t[i]&0xff;
      o[2*i+1]=t[i]>>8;
    }
  }
  \end{lstlisting}

  \subheading{The Montgomery ladder} The full ladder is defined as follow.
  First extract and clamp the value of $n$. Then unpack the value of $p$.
  Compute the Montgomery ladder over the clamped $n$ and $p$, pack the result into $q$.
  \begin{lstlisting}[language=Ctweetnacl]
  int crypto_scalarmult(u8 *q,
                        const u8 *n,
                        const u8 *p)
  {
    u8 z[32];
    i64 r;
    int i;
    gf x,a,b,c,d,e,f;
    FOR(i,31) z[i]=n[i];
    z[31]=(n[31]&127)|64;
    z[0]&=248;
    unpack25519(x,p);
    FOR(i,16) {
      b[i]=x[i];
      d[i]=a[i]=c[i]=0;
    }
    a[0]=d[0]=1;
    for(i=254;i>=0;--i) {
      r=(z[i>>3]>>(i&7))&1;
      sel25519(a,b,r);
      sel25519(c,d,r);
      A(e,a,c);
      Z(a,a,c);
      A(c,b,d);
      Z(b,b,d);
      S(d,e);
      S(f,a);
      M(a,c,a);
      M(c,b,e);
      A(e,a,c);
      Z(a,a,c);
      S(b,a);
      Z(c,d,f);
      M(a,c,_121665);
      A(a,a,d);
      M(c,c,a);
      M(a,d,f);
      M(d,b,x);
      S(b,e);
      sel25519(a,b,r);
      sel25519(c,d,r);
    }
    inv25519(c,c);
    M(a,a,c);
    pack25519(q,a);
    return 0;
  }
  \end{lstlisting}

\subsection{Coq and VST}



Verifying \texttt{crypto\_scalarmult} also implies to verify all the functions
subsequently called: \texttt{unpack25519}; \texttt{A}; \texttt{Z}; \texttt{M};
\texttt{S}; \texttt{car25519}; \texttt{inv25519}; \texttt{set25519}; \texttt{sel25519};
\texttt{pack25519}.

We prove that the implementation of Curve25519 is \textbf{sound} \ie
\begin{itemize}
\item absence of access out-of-bounds of arrays (memory safety).
\item absence of overflows/underflow on the arithmetic.
\end{itemize}
We also prove that TweetNaCl's code is \textbf{correct}:
\begin{itemize}
\item Curve25519 is correctly implemented (we get what we expect).
\item Operations on \texttt{gf} (\texttt{A}, \texttt{Z}, \texttt{M}, \texttt{S})
are equivalent to operations ($+,-,\times,x^2$) in \Zfield.
\item The Montgomery ladder does compute a scalar multiplication between a natural number and a point.
\end{itemize}

In order to prove the soundness and correctness of \texttt{crypto\_scalarmult},
we first create a skeleton of the Montgomery ladder with abstract operations which
can be instanciated over lists, integers, field elements...
A high level specification (over a generic field $\K$) allows use to prove the
correctness of the ladder with respect to the curves theory.
This high specification does not rely on the parameters of Curve25519.
By instanciating $\K$ with $\Zfield$, and the parameters of Curve25519 ($a = 486662, b = 1$),
we define a middle level specification.
Additionally we also provide a low level specification close to the \texttt{C} code
(over lists of $\Z$). We show this specification to be equivalent to the
\textit{semantic version} of C (\texttt{CLight}) with VST.
This low level specification gives us the soundness assurance.
By showing that operations over instances ($\K = \Zfield$, $\Z$, list of $\Z$) are
equivalent we bridge the gap between the low level and the high level specification
with Curve25519 parameters.
As such we prove all specifications to equivalent (Fig.\ref{tk:ProofStructure}).
This garantees us the correctness of the implementation.

\begin{figure}[h]
  \include{tikz/specifications}
  \caption{Structural construction of the proof}
  \label{tk:ProofStructure}
\end{figure}
