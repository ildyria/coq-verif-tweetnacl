\section{Formalizing X25519 from RFC~7748}
\label{sec:Coq-RFC}

In this section we present our formalization of RFC~7748~\cite{rfc7748}.

\begin{informaltheorem}
The specification of X25519 in RFC~7748 is formalized by \Coqe{RFC} in Coq.
\end{informaltheorem}

More precisely, we formalized X25519 with the following definition.
\begin{lstlisting}[language=Coq]
Definition RFC (n: list Z) (p: list Z) : list Z :=
  let k := decodeScalar25519 n in
  let u := decodeUCoordinate p in
  let t := montgomery_rec
    255  (* iterate 255 times *)
    k    (* clamped n         *)
    1    (* x_2                *)
    u    (* x_3                *)
    0    (* z_2                *)
    1    (* z_3                *)
    0    (* dummy             *)
    0    (* dummy             *)
    u    (* x_1                *) in
  let a := get_a t in
  let c := get_c t in
  let o := ZPack25519 (Z.mul a (ZInv25519 c))
  in encodeUCoordinate o.
\end{lstlisting}

In this definition \coqe{montgomery_rec} is defined as follows:

\begin{lstlisting}[language=Coq]
Fixpoint montgomery_rec (m : nat) (z : T')
(a: T) (b: T) (c: T) (d: T) (e: T) (f: T) (x: T) :
(* a: x2              *)
(* b: x3              *)
(* c: z2              *)
(* d: z3              *)
(* e: temporary  var  *)
(* f: temporary  var  *)
(* x: x1              *)
(T * T * T * T * T * T) :=
match m with
| 0%nat => (a,b,c,d,e,f)
| S n =>
  let r := Getbit (Z.of_nat n) z in
    (* k_t = (k >> t) & 1                       *)
    (* swap <- k_t                              *)
  let (a, b) := (Sel25519 r a b, Sel25519 r b a) in
    (* (x_2, x_3) = cswap(swap, x_2, x_3)            *)
  let (c, d) := (Sel25519 r c d, Sel25519 r d c) in
    (* (z_2, z_3) = cswap(swap, z_2, z_3)            *)
  let e := a + c in  (* A = x_2 + z_2              *)
  let a := a - c in  (* B = x_2 - z_2              *)
  let c := b + d in  (* C = x_3 + z_3              *)
  let b := b - d in  (* D = x_3 - z_3              *)
  let d := e ^2 in    (* AA = A^2                  *)
  let f := a ^2 in    (* BB = B^2                  *)
  let a := c * a in  (* CB = C * B               *)
  let c := b * e in  (* DA = D * A               *)
  let e := a + c in  (* x_3 = (DA + CB)^2          *)
  let a := a - c in  (* z_3 = x_1 * (DA - CB)^2     *)
  let b := a ^2 in    (* z_3 = x_1 * (DA - CB)^2     *)
  let c := d - f in  (* E = AA - BB             *)
  let a := c * C_121665 in
                     (* z_2 = E * (AA + a24 * E) *)
  let a := a + d in  (* z_2 = E * (AA + a24 * E) *)
  let c := c * a in  (* z_2 = E * (AA + a24 * E) *)
  let a := d * f in  (* x_2 = AA * BB            *)
  let d := b * x in  (* z_3 = x_1 * (DA - CB)^2    *)
  let b := e ^2 in    (* x_3 = (DA + CB)^2         *)
  let (a, b) := (Sel25519 r a b, Sel25519 r b a) in
    (* (x_2, x_3) = cswap(swap, x_2, x_3)           *)
  let (c, d) := (Sel25519 r c d, Sel25519 r d c) in
    (* (z_2, z_3) = cswap(swap, z_2, z_3)           *)
  montgomery_rec n z a b c d e f x
end.
\end{lstlisting}

The functions encoding and decoding of the byte array are detailed in
\ref{subsec:integer-bytes}.

RFC~7748 states \emph{``All calculations are performed in GF(p), i.e., they are performed modulo p.''}
Operations used in the Montgomery ladder of \coqe{RFC} are intentiated over
integers $Z$ (See Appendix~\ref{subsubsec:RFC-Coq}). The modulo reduction by $\p$
is deferred at the end with the \coqe{ZPack25519} operation.
We define $\Zfield$ as integers in which the modulo reduction by $\p$ is
deferred at the end to the computations.
We use this notation to emphasis its difference with $\Ffield$ where the
modulo by $\p$ is applied in each operations.

We briefly introduce our generic description of the Montgomery ladder (\ref{subsec:spec-ladder}).
Then we describe our mapping between little-endian representations and integers
(\ref{subsec:integer-bytes}) which we use to formalize the encoding and decoding.



% subsection or subheading ?
\subsection{A generic ladder}
\label{subsec:spec-ladder}



TweetNaCl implements X25519 with numbers represented as arrays.
RFC~7748 defines X25519 over field elements. We show the equivalence between
the different number representations. To simplify our proof, we define operations
used in the ladder over generic types \coqe{T} and \coqe{T'}.
Those types are later instantiated as list of integers, integers, natural
numbers, field elements.

% The generic definition of the ladder (\coqe{montgomery_rec}) and its parallel with
% the definition of RFC~7748 are provided in Appendix~\ref{subsubsec:coq-ladder}.

Our formalization differs slightly from the RFC. Indeed in order to optimize the
number of calls to \texttt{CSWAP} the RFC uses an additional variable to decide
whether a conditional swap is required or not. Our description of the ladder
follows strictly the shape of the exponent as described in \aref{alg:montgomery-ladder}.
This divergence is allowed by the RFC:
\emph{``Note that these formulas are slightly different from Montgomery's
original paper.  Implementations are free to use any correct formulas.''}~\cite{rfc7748}.
We later prove our ladder correct in that respect (\sref{sec:maths}).




\subsection{Integers and Bytes}
\label{subsec:integer-bytes}

\emph{``To implement the X25519(k, u) [...] functions (where k is
the scalar and u is the u-coordinate), first decode k and u and then
perform the following procedure, which is taken from [curve25519] and
based on formulas from [montgomery].  All calculations are performed
in GF(p), i.e., they are performed modulo p.''}~\cite{rfc7748}

In TweetNaCl, as described in \sref{subsec:Number-TweetNaCl}, numbers in
\TNaCle{gf} are represented in base $2^{16}$ and we use a direct mapping to
represent that array as a list of integers in Coq.

We define the little-endian projection to integers as follows.
\begin{dfn}
Let \Coqe{ZofList} : $\Z \rightarrow \texttt{list}~\Z \rightarrow \Z$,
a parameterized map by $n$ between a list $l$ and its little endian representation
with a radix $2^n$.
\end{dfn}
We define it in Coq as:
\begin{lstlisting}[language=Coq]
Fixpoint ZofList {n:Z} (a:list Z) : Z :=
  match a with
  | [] => 0
  | h :: q => h + 2^n * ZofList q
  end.
\end{lstlisting}

\Coqe{ZofList} is used in the decoding of the bytes array and also as a
base to verify operations over lists in TweetNaCl (See~\ref{subsec:num-repr-rfc}).
Similarly the encoding from integers to bytes is defined:
\begin{dfn}
Let \Coqe{ListofZ32} : $\Z \rightarrow \Z \rightarrow \texttt{list}~\Z$, given
$n$ and $a$ returns $a$'s little-endian representation
as a list with radix $2^n$.
\end{dfn}
We define it in Coq as:
\begin{lstlisting}[language=Coq]
Fixpoint ListofZn_fp {n:Z} (a:Z) (f:nat) : list Z :=
match f with
  | 0%nat => []
  | S fuel => (a mod 2^n) :: ListofZn_fp (a/2^n) fuel
end.

Definition ListofZ32 {n:Z} (a:Z) : list Z :=
  ListofZn_fp n a 32.
\end{lstlisting}
In order to increase the trust in our formalization, we prove that
\Coqe{ListofZ32} and \Coqe{ZofList} are inverse to each other.

\begin{lstlisting}[language=Coq]
Lemma ListofZ32_ZofList_Zlength: forall (l:list Z),
  Forall (fun x => 0 <= x < 2^n) l ->
  Zlength l = 32 ->
  ListofZ32 n (ZofList n l) = l.
\end{lstlisting}

With those tools at hand, we formally define the decoding and encoding as
specified in the RFC.

\begin{lstlisting}[language=Coq]
Definition decodeScalar25519 (l: list Z) : Z :=
  ZofList 8 (clamp l).

Definition decodeUCoordinate (l: list Z) : Z :=
  ZofList 8 (upd_nth 31 l
    (Z.land (nth 31 l 0) 127)).

Definition encodeUCoordinate (x: Z) : list Z :=
  ListofZ32 8 x.
\end{lstlisting}

In this definition, \coqe{clamp} is taking care of setting and unsetting the
selected bits as per stated in the RFC.
