\section{Curve25519 implementation}

To \texttt{crypto\_scalarmult} we need to prove all the functions it calls:
\texttt{unpack25519}; \texttt{A}; \texttt{Z}; \texttt{M}; \texttt{S};
\texttt{car25519}; \texttt{inv25519}; \texttt{set25519}; \texttt{sel25519};
\texttt{pack25519}.

\subsection{Implementation}

Curve25519 is defined over $\mathbb{Z}_{2^{255}-19}$. Number in that field can
be represented by a 256-bits number. Each of them are cut into 16 limbs of 16
bits placed into 64-bits signed container.
\begin{lstlisting}[language=C]
typedef long long i64;
typedef i64 gf[16];
\end{lstlisting}

This representation allows simple definitions of addition (\texttt{A}),
substraction (\texttt{Z}) and a (school-book) multiplication (\texttt{M}).
\begin{lstlisting}[language=C]
sv A(gf o,const gf a,const gf b) {
  int i;
  FOR(i,16) o[i]=a[i]+b[i];
}

sv M(gf o,const gf a,const gf b) {
  i64 i,j,t[31];
  FOR(i,31) t[i]=0;
  FOR(i,16) FOR(j,16) t[i+j]+=a[i]*b[j];
  FOR(i,15) t[i]+=38*t[i+16];
  FOR(i,16) o[i]=t[i];
  car25519(o);
  car25519(o);
}
\end{lstlisting}

The propagation of carries are taken care of a by the \texttt{car25519} function.
\begin{lstlisting}[language=C]
sv car25519(gf o) {
  int i;
  i64 c;
  FOR(i,16) {
    o[i]+=(1LL<<16);
    c=o[i]>>16;
    o[(i+1)*(i<15)]+=c-1+37*(c-1)*(i==15);
    o[i]-=c<<16;
  }
}
\end{lstlisting}

It should be noted that this representation does not guaranties uniqueness. i.e.
\begin{align*}
  \exists x,y \in \texttt{gf} \text{ such that }\\
  x \neq y\ \land \\
  x \bmod{2^{255}-19} = y \bmod{2^{255}-19}
\end{align*}

\subsection{What need to be proven?}

\textbf{Soundness} and \textbf{Correctness}.

We show that TweetNaCl's code is \textbf{sound} also know as \textit{shape analysis} \ie

\begin{itemize}
\item absence of array out-of-bounds,
\textit{For each array access, VST requires to prove the range.}
\item absence of overflows/underflow.
\textit{for each operation, VST requires to prove that the resulting value are in ranges.}
\end{itemize}

We also show that TweetNaCl's code is \textbf{correct}:

\begin{itemize}
\item Curve25519 is correctly implemented
\item The number representation
\end{itemize}

\subsection{Correctness Theorem}

The soundness is implied by the functionnal definition of the following theorem.
Indeed, showing equivalence between the Clight representation and a Coq
definition of the ladder garantees us the soundness.

\begin{lstlisting}
Definition crypto_scalarmult_spec :=
 DECLARE _crypto_scalarmult_curve25519_tweet
 WITH
  q: val, n: val, p: val, c121665:val,
  sh : share,
  qq : list Z,
  nn : list Z,
  pp : list Z

 (* Preconditions *)
 PRE [ _q OF (tptr tuchar),
       _n OF (tptr tuchar),
       _p OF (tptr tuchar) ]
  PROP  (writable_share sh;
    Forall (fun x => 0 <= x < Z.pow 2 8) pp;
    Forall (fun x => 0 <= x < Z.pow 2 8) nn;
    Zlength qq = 32;
    Zlength nn = 32;
    Zlength pp = 32)
  LOCAL(temp _q q; temp _n n; temp _p p;
        gvar __121665 c121665)
 SEP  (sh [{ q }] <<(uch32)-- mVI qq;
    sh [{ n }] <<(uch32)-- mVI nn;
    sh [{ p }] <<(uch32)-- mVI pp;
    Ews [{ c121665 }] <<(uch32)-- mVI64 c_121665)

 (* Resulting Postconditions *)
 POST [ tint ]
  PROP (
    Forall (fun x => 0 <= x < Z.pow 2 8)
      (sc_mult nn pp);
      (* WE CAN ADD MORE LEMMAS HERE *)
    Zlength (sc_mult nn pp) = 32)
  LOCAL()
  SEP (sh [{ q }] <<(uch32)-- mVI (sc_mult nn pp);
    sh [{ n }] <<(uch32)-- mVI nn;
    sh [{ p }] <<(uch32)-- mVI pp;
    Ews [{ c121665 }] <<(uch32)-- mVI64 c_121665).
\end{lstlisting}

In this theorem we declare that the function \texttt{crypto\_scalarmult} takes as
input three pointers to arrays of unsigned bytes (\texttt{tptr tuchar}) \texttt{p},
\texttt{q} and \texttt{n}.
Each of them respectively points to the values \texttt{pp},  \texttt{qq} and  \texttt{nn}
represented by a list of integers in Coq. In order to guarantee the equivalence
we assume the values in \texttt{pp} and \texttt{nn} being bounded by $0$ included
and $2^8$ excluded.

This function computes: $$Q \leftarrow n \times P$$

\texttt{pp} represent the x-coordinate of $P$, \texttt{nn} represent the
scalar by which it is be multiplied $n$ (where the bits 1, 2, 5 248, 249, 250
are cleared and bit 6 is set).

As a result of the excution of \texttt{crypto\_scalarmult}, the value \texttt{0} is returned,
\texttt{p} and \texttt{n} points to the same locations containing the same values \texttt{pp} and \texttt{nn}.
The pointer \texttt{q} points to the same location, but contain the x coordinate of $Q$.
