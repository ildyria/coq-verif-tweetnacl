\section{Linking C and Coq}

In this section we describe techniques used to prove the equivalence between the
Clight description of TweetNaCl and Coq functions producing similar behaviors.

\subsection{Number representation and C implementation}

As described in Section \ref{sec:impl}, numbers in \TNaCle{gf} are represented
in base $2^{16}$ and we can use a direct mapping to represent that array as a list
integers in Coq. However in order to show the correctness of the basic operations,
we need to convert this number as a full integer. For this reason we define
\coqDe{ZofList : Z -> list Z -> Z}:
\begin{coqD}
Fixpoint ZofList {n:Z} (a:list Z) : Z :=
  match a with
  | [] => 0
  | h :: q => h + (pow 2 n) * ZofList q
  end.
Notation "Z16.lst A" := (ZofList 16 A).
\end{coqD}
It converts any list of integer from a base $2^n$ to an single integer. In our
case we define a notation where $n$ is $16$.

The following Coq notation is defined to convert any integer to its representant
in \Zfield.
\begin{coqD}
Notation "A :GF" := (A mod (2^255-19)).
\end{coqD}

Using these two definitions, we proved lemmas such as the correctness of the
multiplication \coqDe{M}:
\begin{coqD}
Lemma mult_GF_Zlength :
  forall (a:list Z) (b:list Z),
  Zlength a = 16 ->
  Zlength b = 16 ->
   (Z16.lst (M a b)) :GF =
   (Z16.lst a * Z16.lst b) :GF.
\end{coqD}

For all list of integers \texttt{a} and \texttt{b} of length 16 representing
$A$ and $B$ in \Zfield, the number represented in \Zfield by the list \coqDe{(M a b)}
is equal to $A \times B \bmod 2^{255}-19$.

In a similar fashion we can define a Coq version of the inversion mimicking
the behavior of \TNaCle{inv25519} over \coqDe{list Z}. \coqDe{step_pow} contains
the body of the for loop.

\begin{coqD}
Definition step_pow (a:Z) (c g:list Z) : list Z :=
  let c := Sq c in
    if a <>? 1 && a <>? 3
    then M c g
    else c.
\end{coqD}

\coqDe{pow_fn_rev} is responsible of the iteration of the loop by making
recursive calls.
\begin{coqD}
Function pow_fn_rev (a:Z) (b:Z) (c g: list Z)
  {measure Z.to_nat a} : (list Z) :=
  if a <=? 0
    then c
    else
      let prev := pow_fn_rev (a - 1) b c g in
        step_pow (b - 1 - a) prev g.
\end{coqD}

% This \coqDe{Function} requires a proof of termination. It is done by proving the
% Well-foundness of the decreasing argument: \coqDe{measure Z.to_nat a}.

Calling \coqDe{pow_fn_rev} 254 times allows us to reproduce the same behavior as
the Clight definition.
\begin{coqD}
Definition Inv25519 (x:list Z) : list Z :=
  pow_fn_rev 254 254 x x.
\end{coqD}

\subsection{Inversions and Reflections}

In TweetNaCl, \TNaCle{inv25519} computes an inverse in \Zfield. It uses the
Fermat's little theorem by the exponentiation to $2^{255}-21$. To prove the
correctness of the result we can use multiple strategy such as:
\begin{itemize}
  \item Proving it is special case of square-and-multiply algorithm applied to
  a specific number and then show that this number is indeed $2^{255}-21$.
  \item Unrolling the for loop step-by-step and applying the equalities
  $x^a \times x^b = x^{(a+b)}$ and $(x^a)^2 = x^{(2 \times a)}$. We can prove that
  the resulting exponent is $2^{255}-21$.
\end{itemize}

We choose the second method. The only drawback is that it requires to apply the
unrolling and exponentiation lemmas 255 times. This can be automated in Coq with
tacticals such as \coqDe{repeat}, but it generates a big proof object which
will take a long time to verify.

\subsubsection{Speeding up with Reflections}

In order to speed up the verification, we use a technique called reflection.
It provides us with flexibility such as we don't need to know the  number of
times the lemmas needs to be applied.

The idea is to \textit{reflect} the goal into a decidable environment.
In our case, we show that for a property $P$, we can define a decidable
boolean property $P_{bool}$ such that if $P_{bool}$ is \coqDe{true} then $P$ holds.
$$P_{bool} = true \implies P$$

With VST we proved that \TNaCle{inv25519} in \texttt{Clight} is equivalent to its Coq
functional definition \coqDe{Inv25519}. We also proved that \coqDe{Inv25519}
over \coqDe{list Z} is equivalent to applying
\coqDe{Inv25519_Z} over \coqDe{Z}

% With VST we proved that \TNaCle{inv25519} in \texttt{Clight} is equivalent to its Coq
% functional definition \coqDe{Inv25519}. We also proved that \coqDe{pow_fn_rev}
% over \coqDe{list Z} is equivalent to applying
% \coqDe{pow_fn_rev_Z} over \coqDe{Z}

\begin{coqD}
Lemma Inv25519_Z_GF :
  forall (g:list Z),
  length g = 16 ->
  (Z16.lst (Inv25519 g)) :GF =
  (Inv25519_Z (Z16.lst g)) :GF.
\end{coqD}

% \begin{coqD}
% Lemma pow_fn_rev_Z_GF :
%   forall (a:Z) (b:Z) (c:list Z) (g:list Z),
%   Zlength c = 16 ->
%   Zlength g = 16 ->
%   (Z16.lst (pow_fn_rev a b c g)) :GF =
%   (pow_fn_rev_Z a b (Z16.lst c) (Z16.lst g)) :GF .
% \end{coqD}

where \coqDe{Inv25519_Z} reproduces the same pattern as \coqDe{Inv25519}.

\begin{coqD}
Definition Inv25519_Z (x:Z) : Z :=
  pow_fn_rev_Z 254 254 x x.
\end{coqD}

\coqDe{pow_fn_rev_Z} mimicks \coqDe{pow_fn_rev} over \coqDe{Z} instead of
\coqDe{list Z}. The structure is the same:
the application \coqDe{step_pow_Z} and the loop itself \coqDe{pow_fn_rev_Z}

\begin{coqD}
Definition step_pow_Z (a:Z) (c:Z) (g:Z) : Z :=
  let c := c * c in
  if a <>? 1 && a <>? 3
    then c * g
    else c.

Function pow_fn_rev_Z (a:Z) (b:Z) (c:Z) (g: Z)
  {measure Z.to_nat a} : Z :=
  if (a <=? 0)
    then c
    else
      let prev := pow_fn_rev_Z (a - 1) b c g in
        step_pow_Z (b - 1 - a) prev g.
\end{coqD}
%
% In line with the definition of \coqDe{Inv25519}, we define the inversion modulo
% $2^{255}-19$ as an instance of \coqDe{pow_fn_rev_Z} where \coqDe{a} and \coqDe{b} are 254.

\subsubsection{A Simple Domain Specific Language}

To prove that the \coqDe{Inv25519_Z} is computing $x^{2^{255}-21}$,
we define a Domain Specific Language:
\begin{coqD}
Inductive expr_inv :=
  | R_inv : expr_inv
  | M_inv : expr_inv -> expr_inv -> expr_inv
  | S_inv : expr_inv -> expr_inv
  | P_inv : expr_inv -> positive -> expr_inv.
\end{coqD}
An expression can be either a term, a multiplication, a squaring or a power.
This is denoted as follow:
\begin{coqD}
Fixpoint e_inv_denote (m:expr_inv) : Z :=
  match m with
  | R_inv     =>
    term_denote
  | M_inv x y =>
    (e_inv_denote x) * (e_inv_denote y)
  | S_inv x =>
    (e_inv_denote x) * (e_inv_denote x)
  | P_inv x p =>
    pow (e_inv_denote x) (Z.pos p)
  end.
\end{coqD}

We defined \coqDe{step_inv} and \coqDe{pow_inv} to mirror the behavior of
\coqDe{step_pow_Z} and respectively \coqDe{pow_fn_rev_Z} over our new domain.

\begin{coqD}
Lemma step_inv_step_pow_eq :
  forall (a:Z) (c:expr_inv) (g:expr_inv),
  e_inv_denote (step_inv a c g) =
  step_pow_Z a (e_inv_denote c) (e_inv_denote g).
\end{coqD}
\begin{coqD}
Lemma pow_inv_pow_fn_rev_eq :
  forall (a:Z) (b:Z) (c:expr_inv) (g:expr_inv),
  e_inv_denote (pow_inv a b c g) =
  pow_fn_rev_Z a b (e_inv_denote c) (e_inv_denote g).
\end{coqD}

We also define what is a formula in our language: a simple equality.
\begin{coqD}
Inductive formula_inv :=
  | Eq_inv : expr_inv -> expr_inv -> formula_inv.
\end{coqD}
This is denoted as follow:
\begin{coqD}
Definition f_inv_denote (t : formula_inv) : Prop :=
  match t with
  | Eq_inv x y => e_inv_denote x = e_inv_denote y
  end.
\end{coqD}
With such Domain Specific Language we have the equivalence between:
\begin{lstlisting}[backgroundcolor=\color{white}]
f_inv_denote
 (Eq_inv (M_inv R_inv (S_inv R_inv))
         (P_inv R_inv 3))
  = (x * x^2 = x^3)
\end{lstlisting}

\subsubsection{Deciding formulas}

In order to prove formulas in \coqDe{formula_inv},
we define a decidable procedure.
We first compute the power of each side of the formula and then check their
equality.
\begin{coqD}
Fixpoint pow_expr_inv (t:expr_inv) : Z :=
  match t with
  | R_inv   => 1
  | M_inv x y =>
    (pow_expr_inv x) + (pow_expr_inv y)
  | S_inv x =>
    2 * (pow_expr_inv x)
  | P_inv x p =>
    (Z.pos p) * (pow_expr_inv x)
  end.

Definition decide_e_inv (l1 l2:expr_inv) : bool :=
  (pow_expr_inv l1) ==? (pow_expr_inv l2).

Definition decide_f_inv (f:formula_inv) : bool :=
  match f with
  | Eq_inv x y => decide_e_inv x y
  end.
\end{coqD}
We proved that our procedure is correct: for all formulas in \coqDe{formula_inv}, if
\coqDe{decide_f_inv} returns \coqDe{true}, then the denoted equality is correct.
\begin{coqD}
Lemma decide_formula_inv_impl :
  forall (f:formula_inv),
  decide_f_inv f = true ->
  f_inv_denote f.
\end{coqD}

By reification to our Domain Specific Language and then by applying
\texttt{decide\_formula\_inv\_impl} and computing \texttt{decide\_f\_inv},
we proved that \coqDe{Inv25519} is indeed computing an inverse in
modulo $2^{255}-19$.

\begin{coqD}
Theorem Inv25519_Z_correct :
  forall (x:Z),
  Inv25519_Z x = pow x (2^255-21).
\end{coqD}

From \coqDe{Inv25519_Z_correct} and \coqDe{Inv25519_Z_GF}, we conclude the
functionnal correctness of the inversion over \Zfield.

\begin{coqD}
Corollary Inv25519_Zpow_GF :
  forall (g:list Z),
  length g = 16 ->
  Z16.lst (Inv25519 g) :GF  =
  (pow (Z16.lst g) (2^255-21)) :GF.
\end{coqD}

\subsubsection{Packing and other applications}

Reflection can also be used where proofs requires computing.

\todo[inline]{give other examples where Reflection was applied, e.g. pack25519}

Pack25519 :
prove that the substraction and the carry can be seen as two separate loops instead of a single for.
This simplifies the proof as you just the carrying does not change the value in \Zfield.

Proving equalitives of the form:

\begin{coqD}
[x * y + z * t, x , y * r] =
[t * z + y * x, x , r * y].
\end{coqD}

This is usually solved with the repetition of the \coqDe{f_equal} lemma.

\begin{coqD}
Lemma f_equal :
  forall (A B C:Type) (x y:A) (z t:B) (f:A->B->C),
  x = y -> z = t ->
  f x z = f y t.
\end{coqD}
In this example case it will create two subgoals:
\begin{coqD}
(* 1 *)
x * y + z * t = t * z + y * x
(* 2 *)
[x , y * r] = [x , r * y]
\end{coqD}
The first one will be proven by the \coqDe{ring} tactic which solve simple non-linear goals.
The second one will be proven by the application of \coqDe{f_equal}
followed by \coqDe{ring}. This iteration and call for tactics makes the proofs slow.
Instead of repeating this over the 16 or more elements of the lists, we used a reflection.
We created a decidable procedure over the elements of the list and iterated on them.
