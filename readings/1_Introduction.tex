\section{Introduction}

Implementing cryptographic primitives without any bugs is hard.
While tests provides a some code coverage, they don't cover
100\% of the possible input values. Using Coq, we prove the
correctness of the scalar multiplication in Tweetnacl.

TweetNaCl\cite{BGJ+15} is a compact reimplementation of the
NaCl\cite{BLS12} library. It does not aim for high speed
application and has been optimized for source code compactness.
It maintains some degree of readability in order to be
easily auditable.

This library makes use of Curve25519\cite{Ber06}, an elliptic
curve defined over the field $\mathbb{Z}_{2^{255}-19}$.
It defines the function \texttt{crypto\_scalarmult} which
takes as input a scalar $n$ and the $x$ coordinate of a
point $P$ and returns the $x$ coordinate of the
point $[n]P$.

Coq is a formal system that allows us to machine-check our proofs. The Compcert\cite{Leroy-backend}
compiler and the Verifiable Software Toolchain (VST)\cite{2012-Appel} are build
on top of it.

Our approach is as follow, we use the \textit{clightgen} tool from Compcert to
generate the \textit{semantic version} (Clight\cite{Blazy-Leroy-Clight-09}) of
the TweetNaCl C code. Using the Separation logic\cite{1969-Hoare,Reynolds02separationlogic}
with (VST) we show that the semantics of the program satisfies a functionnal
specification in Coq. We then prove that this specification represent the scalar
multiplication on Curve25519.

\subsection{Meet-in-the-middle Approach}

In order to prove that \texttt{crypto\_scalarmult} is computing a scalar
multiplication over the x-coordinate of a point P, we need to define multiples
levels of specifications and show equivalence between them (Fig.\ref{tk:ProofStructure}).

\begin{enumerate}
  \item Write a high level specification (over a generic field $\mathbb{F}$).
  \item Prove that the high level specification is equivalent to the
  computation of a montgomery ladder.
  \item Write a low level specification (e.g. over lists of $\mathbb{Z}$).
  \item Prove that the low level specification represent the operations of
  defined C code.
  \item Write a middle level specification over $\mathbb{Z}_{2^{255}-19}$.
  \item Prove that the low level specification are equivalent to simple
  operations in $\mathbb{Z}_{2^{255}-19}$ and thus equivalent to the middle level.
  \item Prove that the middle level specification is an instance of the high
  level one.
\end{enumerate}

The equivalence between each level, garantees us the correctness of the
implementation.

\begin{figure}[h]
  \include{tikz/specifications}
  \caption{Structural construction of the proof}
  \label{tk:ProofStructure}
\end{figure}
